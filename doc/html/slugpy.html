<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>slugpy – The Python Helper Library &mdash; slug 2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="slug 2.0 documentation" href="index.html" />
    <link rel="next" title="Test Problems" href="tests.html" />
    <link rel="prev" title="Filters and Filter Data" href="filters.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tests.html" title="Test Problems"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="filters.html" title="Filters and Filter Data"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">slug 2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="slugpy-the-python-helper-library">
<span id="sec-slugpy"></span><h1>slugpy &#8211; The Python Helper Library<a class="headerlink" href="#slugpy-the-python-helper-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="basic-usage">
<h2>Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h2>
<p>SLUG comes with the python module slugpy, which contains an extensive set of routines for reading, writing, and manipulating SLUG outputs. The most common task is to read a set of SLUG outputs into memory so that they can be processed. To read the data from a SLUG run using slugpy, one can simply do the following:</p>
<div class="highlight-rest"><div class="highlight"><pre>from slugpy import *
idata = read_integrated(&#39;SLUG_MODEL_NAME&#39;)
cdata = read_cluster(&#39;SLUG_MODEL_NAME&#39;)
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">read_integrated</span></tt> function reads all the integrated-light data (i.e., the data stored in the <tt class="docutils literal"><span class="pre">_integrated_*</span></tt> files &#8211; see <a class="reference internal" href="output.html#sec-output"><em>Output Files and Format</em></a>) for a SLUG output whose name is given as the argument. This is the base name specified by the <tt class="docutils literal"><span class="pre">model_name</span></tt> keyword (see <a class="reference internal" href="parameters.html#ssec-basic-keywords"><em>Basic Keywords</em></a>), without any extensions; the slugpy library will automatically determine which outputs are available and in what format, and read the appropriate files. It returns a <tt class="docutils literal"><span class="pre">namedtuple</span></tt> containing all the output data available for that simulation. The <tt class="docutils literal"><span class="pre">read_cluster</span></tt> function is analogous, except that instead of reading the whole-galaxy data, it reads data on the individual star clusters, as stored in the <tt class="docutils literal"><span class="pre">_cluster_*</span></tt> output files.</p>
</div>
<div class="section" id="module-slugpy">
<span id="full-documentation"></span><h2>Full Documentation<a class="headerlink" href="#module-slugpy" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="slugpy.combine_cluster">
<tt class="descclassname">slugpy.</tt><tt class="descname">combine_cluster</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#slugpy.combine_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to combine cluster data from multiple SLUG2 runs,
treating each input run as a separate set of trials. Trial and
cluster unique ID numbers are altered as necessary to avoid
duplication between the merged data sets.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">list_like</span></dt>
<dd>A list containing the cluster data for each run, as
returned by read_cluster</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>combined_data <span class="classifier-delimiter">:</span> <span class="classifier">namedtuple</span></dt>
<dd>The combined data, in the same format as each object in data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.combine_integrated">
<tt class="descclassname">slugpy.</tt><tt class="descname">combine_integrated</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#slugpy.combine_integrated" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to combine integrated data from multiple SLUG2 runs,
treating each input run as a separate set of trials.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">list_like</span></dt>
<dd>A list containing the integrated data for each run, as
returned by read_integrated</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>combined_data <span class="classifier-delimiter">:</span> <span class="classifier">namedtuple</span></dt>
<dd>The combined data, in the same format as each object in data</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.compute_photometry">
<tt class="descclassname">slugpy.</tt><tt class="descname">compute_photometry</tt><big>(</big><em>wl</em>, <em>spec</em>, <em>filtername</em>, <em>photsystem='L_nu'</em>, <em>filter_wl=None</em>, <em>filter_response=None</em>, <em>filter_beta=None</em>, <em>filter_wl_c=None</em>, <em>filter_dir=None</em><big>)</big><a class="headerlink" href="#slugpy.compute_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>This function takes an input spectrum and a set of response
functions for photometric filters, and returns the photometry
through those filters.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>Wavelength of input spectrum in Angstrom</dd>
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>Specific luminosity per unit wavelength for input spectrum, in
erg/s/A</dd>
<dt>filtername <span class="classifier-delimiter">:</span> <span class="classifier">string or iterable of strings</span></dt>
<dd>Name or list of names of the filters to be used. Filter names
can also include the special filters Lbol, QH0, QHe0, and QHe1;
the values returned for these will be the bolometric luminosity
(in erg/s) and the photon luminosities (in photons/s) in the H,
He, and He+ ionizing-continua, respectively.</dd>
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The photometric system to use for the output. Allowable values
are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;, &#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;,
corresponding to the options defined in the SLUG code.</dd>
<dt>filter_wl <span class="classifier-delimiter">:</span> <span class="classifier">array or iterable of arrays</span></dt>
<dd>Array giving the wavelengths in Angstrom at which the filter is
response function is given. If this object is an iterable of
arrays rather than a single array, it is assumed to represent
the wavelengths for a set of filters. If this is set,
no data is read from disk. Default behavior is to read the
filter information from disk.</dd>
<dt>filter_response <span class="classifier-delimiter">:</span> <span class="classifier">array or iterable of arrays</span></dt>
<dd>Array giving the filter response function at each wavelenght
and for each filter in filter_wl. Must be set if filter_wl is
set, ignored otherwise.</dd>
<dt>filter_beta <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>Array-like object containing the index beta for each
filter. Must be set if filter_wl is set, ignored otherwise.</dd>
<dt>filter_wl_c <span class="classifier-delimiter">:</span> <span class="classifier">iterable</span></dt>
<dd>Array-like object containing the pivot wavelength for each
filter. Must be set if filter_wl is set, ignored otherwise.</dd>
<dt>filter_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Directory where the filter data files can be found. If left as
None, filters will be looked for in the $SLUG_DIR/lib/filters
directory. This parameter is used only if filtername is not
None.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>Photometric values in the requested filters. Units depend on
the choice of photometric system:
L_nu &#8211;&gt; erg/s/Hz;
L_lambda &#8211;&gt; erg/s/A;
AB &#8211;&gt; absolute AB magnitude;
STMAG &#8211;&gt; absolute ST magnitude;
Vega &#8211;&gt; absolute Vega magnitude;</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.photometry_convert">
<tt class="descclassname">slugpy.</tt><tt class="descname">photometry_convert</tt><big>(</big><em>photsystem</em>, <em>phot</em>, <em>units</em>, <em>wl_cen=None</em>, <em>filter_last=False</em><big>)</big><a class="headerlink" href="#slugpy.photometry_convert" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to convert photometric data between photometric systems.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The photometric system to which to convert. Allowable values
are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;, &#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;,
corresponding to the options defined in the SLUG code. If this
is set and the conversion requested involves a conversion from
a wavelength-based system to a frequency-based one, wl_cen must
not be None.</dd>
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of photometric data; if the array has more than one
dimension, the first dimension is assumed to represent the
different photometric filters</dd>
<dt>units <span class="classifier-delimiter">:</span> <span class="classifier">iterable of strings</span></dt>
<dd>iterable listing the units of the input photometric data. On
return, strings will be changed to the units of the new system.</dd>
<dt>wl_cen <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>central wavelengths of the filters, in Angstrom; can be left as
None if the requested conversion doesn&#8217;t require going between
wavelength- and frequency-based systems.</dd>
<dt>filter_last <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If the input data have more than one dimension, by default it
is assumed that the first dimension contains values for the
different photometric filters. If this keyword is set to True,
it will instead be assumed that the last dimension contains the
values for the different filters.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
<dt>Raises</dt>
<dd>ValueError, if wl_cen is None but the requested conversion
requires going between wavelength- and frequency-based systems</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_cluster">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_cluster</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>nofilterdata=False</em>, <em>photsystem=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read all cluster data for a SLUG2 run.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>nofilterdata <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the routine does not attempt to read the filter
response data from the standard location</dd>
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">None or string</span></dt>
<dd>If photsystem is None, the data will be returned in the same
photometric system in which they were read. Alternately, if it
is a string, the data will be converted to the specified
photometric system. Allowable values are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;,
&#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;, corresponding to the options defined
in the SLUG code. If this is set and the conversion requested
involves a conversion from a wavelength-based system to a
frequency-based one, nofilterdata must be False so that the
central wavelength of the photometric filters is available.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;prop_name&#8217;,
&#8216;phot_name&#8217;, &#8216;spec_name&#8217;, &#8216;cloudyspec_name&#8217;, &#8216;cloudylines_name&#8217;
and &#8216;format&#8217;, giving the names of the files read and the format
they were in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or
&#8216;fits&#8217;. If one of the files is not present, the corresponding
_name key will be omitted from the dict.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<p>(Always present)</p>
<dl class="docutils">
<dt>id <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype uint</span></dt>
<dd>unique ID of cluster</dd>
<dt>trial: array, dtype uint</dt>
<dd>which trial was this cluster part of</dd>
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time at which cluster&#8217;s properties are being evaluated</dd>
</dl>
<p>(Present if the run being read contains a cluster_prop file)</p>
<dl class="docutils">
<dt>form_time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time when cluster formed</dd>
<dt>lifetime <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time at which cluster will disrupt</dd>
<dt>target_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>target cluster mass</dd>
<dt>actual_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>actual mass at formation</dd>
<dt>live_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>mass of currently living stars</dd>
<dt>num_star <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype ulonglong</span></dt>
<dd>number of living stars in cluster being treated stochastically</dd>
<dt>max_star_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>mass of most massive living star in cluster</dd>
</dl>
<p>(Present if the run being read contains a cluster_spec file)</p>
<dl class="docutils">
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>wavelength, in Angstrom</dd>
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_cluster, N_wavelength)</span></dt>
<dd>specific luminosity of each cluster at each wavelength, in erg/s/A</dd>
</dl>
<p>(Present if the run being read contains a cluster_phot file)</p>
<dl class="last docutils">
<dt>filter_names <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the name for each filter</dd>
<dt>filter_units <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the units for each filter</dd>
<dt>filter_wl_cen <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>central wavelength of each filter; this is set to None for the
filters Lbol, QH0, QHe0, and QHe1; omitted if nofilterdata is
True</dd>
<dt>filter_wl <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the wavelength table for each filter; this is
None for the filters Lbol, QH0, QHe0, and QHe1; omitted if
nofilterdata is True</dd>
<dt>filter_response <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the photon response function for each filter;
this is None for the filters Lbol, QH0, QHe0, and QHe1; omitted
if nofilterdata is True</dd>
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_cluster, N_filter)</span></dt>
<dd>photometric value in each filter for each cluster; units are as
indicated in the units field</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if no photometry file can be opened
ValueError, if photsystem is set to an unknown values</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_cluster_phot">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_cluster_phot</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>nofilterdata=False</em>, <em>photsystem=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_cluster_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 cluster_phot file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>nofilterdata <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the routine does not attempt to read the filter
response data from the standard location</dd>
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">None or string</span></dt>
<dd>If photsystem is None, the data will be returned in the same
photometric system in which they were read. Alternately, if it
is a string, the data will be converted to the specified
photometric system. Allowable values are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;,
&#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;, corresponding to the options defined
in the SLUG code. If this is set and the conversion requested
involves a conversion from a wavelength-based system to a
frequency-based one, nofilterdata must be False so that the
central wavelength of the photometric filters is available.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>id <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype uint</span></dt>
<dd>unique ID of cluster</dd>
<dt>trial: array, dtype uint</dt>
<dd>which trial was this cluster part of</dd>
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>times at which cluster spectra are output, in yr</dd>
<dt>filter_names <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the name for each filter</dd>
<dt>filter_units <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the units for each filter</dd>
<dt>filter_wl_eff <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>effective wavelength of each filter; this is set to None for the
filters Lbol, QH0, QHe0, and QHe1; omitted if nofilterdata is
True</dd>
<dt>filter_wl <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the wavelength table for each filter; this is
None for the filters Lbol, QH0, QHe0, and QHe1; omitted if
nofilterdata is True</dd>
<dt>filter_response <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the photon response function for each filter;
this is None for the filters Lbol, QH0, QHe0, and QHe1; omitted
if nofilterdata is True</dd>
<dt>filter_beta <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>powerlaw index beta for each filter; used to normalize the
photometry</dd>
<dt>filter_wl_c <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>pivot wavelength for each filter; used to normalize the photometry</dd>
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_cluster, N_filter)</span></dt>
<dd>photometric value in each filter for each cluster; units are as
indicated in the units field</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if no photometry file can be opened
ValueError, if photsystem is set to an unknown values</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_cluster_prop">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_cluster_prop</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_cluster_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 cluster_prop file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>id <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype uint</span></dt>
<dd>unique ID of cluster</dd>
<dt>trial: array, dtype uint</dt>
<dd>which trial was this cluster part of</dd>
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time at which cluster&#8217;s properties are being evaluated</dd>
<dt>form_time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time when cluster formed</dd>
<dt>lifetime <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>time at which cluster will disrupt</dd>
<dt>target_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>target cluster mass</dd>
<dt>actual_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>actual mass at formation</dd>
<dt>live_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>mass of currently living stars</dd>
<dt>num_star <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype ulonglong</span></dt>
<dd>number of living stars in cluster being treated stochastically</dd>
<dt>max_star_mass <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>mass of most massive living star in cluster</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_cluster_spec">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_cluster_spec</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_cluster_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 cluster_spec file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>id <span class="classifier-delimiter">:</span> <span class="classifier">array, dtype uint</span></dt>
<dd>unique ID of cluster</dd>
<dt>trial: array, dtype uint</dt>
<dd>which trial was this cluster part of</dd>
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>times at which cluster spectra are output, in yr</dd>
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>wavelength, in Angstrom</dd>
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_cluster, N_wavelength)</span></dt>
<dd>specific luminosity of each cluster at each wavelength, in erg/s/A</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if no spectrum file can be opened</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_filter">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_filter</tt><big>(</big><em>filtername</em>, <em>filter_dir=None</em><big>)</big><a class="headerlink" href="#slugpy.read_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a filter or set of filters for SLUG2. By default
this function searches the SLUG_DIR/lib/filter directory, followed
by the current working directory. This can be overridden by the
filter_dir keyword.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>filtername <span class="classifier-delimiter">:</span> <span class="classifier">string or iterable containing strings</span></dt>
<dd>Name or names of filters to be read; for the special filters
Lbol, QH0, QHe0, and QHe1, the return value will be None</dd>
<dt>filter_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Directory where the filter data files can be found</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>wl_eff <span class="classifier-delimiter">:</span> <span class="classifier">float or array</span></dt>
<dd>Central wavelength of the filter, defined by 
wl_eff = exp(int R ln lambda dln lambda / int R dln lambda)</dd>
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array or list of arrays</span></dt>
<dd>Wavelength table for each filter, in Ang</dd>
<dt>response <span class="classifier-delimiter">:</span> <span class="classifier">array or list of arrays</span></dt>
<dd>Response function per photon for each filter</dd>
<dt>beta <span class="classifier-delimiter">:</span> <span class="classifier">float or array</span></dt>
<dd>Index beta for the filter</dd>
<dt>wl_c <span class="classifier-delimiter">:</span> <span class="classifier">float or array</span></dt>
<dd>Pivot wavelength for the filter; used when beta != 0 to
normalize the photometry</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if the filter data files cannot be opened, or if the
requested filter cannot be found</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_integrated">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_integrated</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>nofilterdata=False</em>, <em>photsystem=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_integrated" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read all integrated light data for a SLUG2 run.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>nofilterdata <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the routine does not attempt to read the filter
response data from the standard location</dd>
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">None or string</span></dt>
<dd>If photsystem is None, the data will be returned in the same
photometric system in which they were read. Alternately, if it
is a string, the data will be converted to the specified
photometric system. Allowable values are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;,
&#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;, corresponding to the options defined
in the SLUG code. If this is set and the conversion requested
involves a conversion from a wavelength-based system to a
frequency-based one, nofilterdata must be False so that the
central wavelength of the photometric filters is available.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;prop_name&#8217;,
&#8216;phot_name&#8217;, &#8216;spec_name&#8217;, &#8216;cloudyspec_name&#8217;, &#8216;cloudylines_name&#8217;
and &#8216;format&#8217;, giving the names of the files read and the format
they were in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or
&#8216;fits&#8217;. If one of the files is not present, the corresponding
_name key will be omitted from the dict.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<p>(Always present)</p>
<dl class="docutils">
<dt>time: array</dt>
<dd>Times at which data are output</dd>
</dl>
<p>(Only present if an integrated_prop file is found)</p>
<dl class="docutils">
<dt>target_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times)</span></dt>
<dd>Target stellar mass at each time</dd>
<dt>actual_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Actual mass of stars created up to each time in each trial</dd>
<dt>live_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Mass of currently-alive stars at each time in each trial</dd>
<dt>cluster_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Mass of living stars in non-disrupted clusters at each time in
each trial</dd>
<dt>num_clusters <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of non-disrupted clusters present at each time in each
trial</dd>
<dt>num_dis_clusters <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of disrupted clusters present at each time in each trial</dd>
<dt>num_fld_stars <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of living field stars (excluding those in disrupted 
clusters and those being treated non-stochastically) present at
each time in each trial</dd>
</dl>
<p>(Only present if an integrated_spec file is found)</p>
<dl class="docutils">
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>wavelengths, in Angstrom</dd>
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_wavelength, N_times, N_trials)</span></dt>
<dd>specific luminosity at each wavelength and each time for each
trial, in erg/s/A</dd>
</dl>
<p>(Only present if an integrated_phot file is found)</p>
<dl class="last docutils">
<dt>filter_names <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the name for each filter</dd>
<dt>filter_units <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the units for each filter</dd>
<dt>filter_wl_cen <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>central wavelength of each filter; this is set to None for the
filters Lbol, QH0, QHe0, and QHe1; omitted if nofilterdata is
True</dd>
<dt>filter_wl <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the wavelength table for each filter; this is
None for the filters Lbol, QH0, QHe0, and QHe1; omitted if
nofilterdata is True</dd>
<dt>filter_response <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the photon response function for each filter;
this is None for the filters Lbol, QH0, QHe0, and QHe1; omitted
if nofilterdata is True</dd>
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_filter, N_times, N_trials)</span></dt>
<dd>photometric value in each filter at each time in each trial;
units are as indicated in the units field</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_integrated_phot">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_integrated_phot</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>nofilterdata=False</em>, <em>photsystem=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_integrated_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 integrated_phot file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>nofilterdata <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, the routine does not attempt to read the filter
response data from the standard location</dd>
<dt>photsystem <span class="classifier-delimiter">:</span> <span class="classifier">None or string</span></dt>
<dd>If photsystem is None, the data will be returned in the same
photometric system in which they were read. Alternately, if it
is a string, the data will be converted to the specified
photometric system. Allowable values are &#8216;L_nu&#8217;, &#8216;L_lambda&#8217;,
&#8216;AB&#8217;, &#8216;STMAG&#8217;, and &#8216;Vega&#8217;, corresponding to the options defined
in the SLUG code. If this is set and the conversion requested
involves a conversion from a wavelength-based system to a
frequency-based one, nofilterdata must be False so that the
central wavelength of the photometric filters is available.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>times at which colors are output, in yr</dd>
<dt>filter_names <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the name for each filter</dd>
<dt>filter_units <span class="classifier-delimiter">:</span> <span class="classifier">list of string</span></dt>
<dd>a list giving the units for each filter</dd>
<dt>filter_wl_eff <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>effective wavelength of each filter; this is set to None for the
filters Lbol, QH0, QHe0, and QHe1; omitted if nofilterdata is
True</dd>
<dt>filter_wl <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the wavelength table for each filter; this is
None for the filters Lbol, QH0, QHe0, and QHe1; omitted if
nofilterdata is True</dd>
<dt>filter_response <span class="classifier-delimiter">:</span> <span class="classifier">list of arrays</span></dt>
<dd>a list giving the photon response function for each filter;
this is None for the filters Lbol, QH0, QHe0, and QHe1; omitted
if nofilterdata is True</dd>
<dt>filter_beta <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>powerlaw index beta for each filter; used to normalize the
photometry</dd>
<dt>filter_wl_c <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd>pivot wavelength for each filter; used to normalize the photometry</dd>
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_filter, N_times, N_trials)</span></dt>
<dd>photometric value in each filter at each time in each trial;
units are as indicated in the units field</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if no photometry file can be opened
ValueError, if photsystem is set to an unknown value</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_integrated_prop">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_integrated_prop</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_integrated_prop" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 integrated_prop file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>Times at which data are output</dd>
<dt>target_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape</span></dt>
<dd>Target stellar mass at each time</dd>
<dt>actual_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Actual mass of stars created up to each time in each trial</dd>
<dt>live_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Mass of currently-alive stars at each time in each trial</dd>
<dt>cluster_mass <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials)</span></dt>
<dd>Mass of living stars in non-disrupted clusters at each time in
each trial</dd>
<dt>num_clusters <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of non-disrupted clusters present at each time in each
trial</dd>
<dt>num_dis_clusters <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of disrupted clusters present at each time in each trial</dd>
<dt>num_fld_stars <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_times, N_trials), dtype ulonglong</span></dt>
<dd>Number of living field stars (excluding those in disrupted 
clusters and those being treated non-stochastically) present at
each time in each trial</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_integrated_spec">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_integrated_spec</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em>, <em>fmt=None</em>, <em>verbose=False</em>, <em>read_info=None</em><big>)</big><a class="headerlink" href="#slugpy.read_integrated_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to read a SLUG2 integrated_spec file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
<dt>verbose <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>If True, verbose output is printed as code runs</dd>
<dt>read_info <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>On return, this dict will contain the keys &#8216;fname&#8217; and
&#8216;format&#8217;, giving the name of the file read and the format it
was in; &#8216;format&#8217; will be one of &#8216;ascii&#8217;, &#8216;binary&#8217;, or &#8216;fits&#8217;</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><p class="first">A namedtuple containing the following fields:</p>
<dl class="last docutils">
<dt>time <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>times at which spectra are output, in yr</dd>
<dt>wl <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>wavelength, in Angstrom</dd>
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N_wavelength, N_times, N_trials)</span></dt>
<dd>specific luminosity at each wavelength and each time for each
trial, in erg/s/A</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.read_summary">
<tt class="descclassname">slugpy.</tt><tt class="descname">read_summary</tt><big>(</big><em>model_name</em>, <em>output_dir=None</em><big>)</big><a class="headerlink" href="#slugpy.read_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to open a SLUG output summary file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The name of the model to be read</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the SLUG_DIR
directory if that environment variable is set</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>summary <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd>A dict containing all the keywords stored in the output file</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if a summary file for the specified model cannot be found</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.slug_open">
<tt class="descclassname">slugpy.</tt><tt class="descname">slug_open</tt><big>(</big><em>filename</em>, <em>output_dir=None</em>, <em>fmt=None</em><big>)</big><a class="headerlink" href="#slugpy.slug_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to open a SLUG2 output file.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Name of the file to open, without any extension. The following
extensions are tried, in order: .txt, .bin, .fits</dd>
<dt>output_dir <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>The directory where the SLUG2 output is located; if set to None,
the current directory is searched, followed by the
SLUG_DIR/output directory if the SLUG_DIR environment variable
is set</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the file to be read. Allowed values are &#8216;ascii&#8217;,
&#8216;bin&#8217; or &#8216;binary, and &#8216;fits&#8217;. If one of these is set, the code
will only attempt to open ASCII-, binary-, or FITS-formatted
output, ending in .txt., .bin, or .fits, respectively. If set
to None, the code will try to open ASCII files first, then if
it fails try binary files, and if it fails again try FITS
files.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>fp <span class="classifier-delimiter">:</span> <span class="classifier">file or astropy.io.fits.hdu.hdulist.HDUList</span></dt>
<dd>A file object pointing the file that has been opened</dd>
<dt>fname <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Name of the file that was opened</dd>
</dl>
</dd>
<dt>Raises</dt>
<dd>IOError, if a file of the specified name cannot be found</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.write_cluster">
<tt class="descclassname">slugpy.</tt><tt class="descname">write_cluster</tt><big>(</big><em>data</em>, <em>model_name</em>, <em>fmt</em><big>)</big><a class="headerlink" href="#slugpy.write_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to write a set of output cluster files in SLUG2 format,
starting from a cluster data set as returned by read_cluster.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">namedtuple</span></dt>
<dd>Cluster data to be written, in the namedtuple format returned
by read_cluster</dd>
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Base file name to give the model to be written. Can include a
directory specification if desired.</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the output file. Allowed values are &#8216;ascii&#8217;, &#8216;bin&#8217;
or &#8216;binary, and &#8216;fits&#8217;.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="slugpy.write_integrated">
<tt class="descclassname">slugpy.</tt><tt class="descname">write_integrated</tt><big>(</big><em>data</em>, <em>model_name</em>, <em>fmt</em><big>)</big><a class="headerlink" href="#slugpy.write_integrated" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to write a set of output integrated files in SLUG2 format,
starting from an integrated data set as returned by
read_integrated.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>data <span class="classifier-delimiter">:</span> <span class="classifier">namedtuple</span></dt>
<dd>Integrated data to be written, in the namedtuple format returned
by read_integrated</dd>
<dt>model_name <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Base file name to give the model to be written. Can include a
directory specification if desired.</dd>
<dt>fmt <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Format for the output file. Allowed values are &#8216;ascii&#8217;, &#8216;bin&#8217;
or &#8216;binary, and &#8216;fits&#8217;.</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
</dl>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">slugpy &#8211; The Python Helper Library</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic Usage</a></li>
<li><a class="reference internal" href="#module-slugpy">Full Documentation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="filters.html"
                        title="previous chapter">Filters and Filter Data</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="tests.html"
                        title="next chapter">Test Problems</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/slugpy.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="tests.html" title="Test Problems"
             >next</a> |</li>
        <li class="right" >
          <a href="filters.html" title="Filters and Filter Data"
             >previous</a> |</li>
        <li><a href="index.html">slug 2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Krumholz, Robert da Silva, Michele Fumagalli, Jonathan Parra, Teddy Rendahl, Michelle Myers.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>