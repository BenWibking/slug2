<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bayesphot: Bayesian Inference for Stochastic Stellar Populations &mdash; slug 2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="slug 2.0 documentation" href="index.html" />
    <link rel="next" title="cluster_slug: Bayesian Inference of Star Cluster Properties" href="cluster_slug.html" />
    <link rel="prev" title="cloudy_slug: An Automated Interface to cloudy" href="cloudy.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cluster_slug.html" title="cluster_slug: Bayesian Inference of Star Cluster Properties"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cloudy.html" title="cloudy_slug: An Automated Interface to cloudy"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">slug 2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="bayesphot-bayesian-inference-for-stochastic-stellar-populations">
<span id="sec-bayesphot"></span><h1>bayesphot: Bayesian Inference for Stochastic Stellar Populations<a class="headerlink" href="#bayesphot-bayesian-inference-for-stochastic-stellar-populations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-does-bayesphot-do">
<h2>What Does bayesphot Do?<a class="headerlink" href="#what-does-bayesphot-do" title="Permalink to this headline">¶</a></h2>
<p>Bayesphot is a package for performing Bayesian inference for the physical properties of a stellar system using its measured photometric properties, in a case where the photometric properties vary non-deterministically with the physical properties. Formally, bayesphot answers the following question: consider a stellar system characterized by a vector of <span class="math">\(\mathbf{x} = (x_1, x_2, \ldots x_N)\)</span> physical properties. We have a physical model that lets us sample the expected photometric properties as a function of physical properties, i.e., that for some sample of <span class="math">\(K\)</span> systems with physical properties <span class="math">\(\mathbf{x}_k\)</span> we are able to compute the corresponding photometric properties <span class="math">\(\mathbf{y}_k = \mathbf{y} = (y_1, y_2, \ldots y_M)_k\)</span>. Now suppose that we observe such a system, and we observe it to have photometric properties <span class="math">\(\mathbf{y}_{\mathrm{obs}}\)</span>, with some set of photometric errors <span class="math">\(\mathbf{\sigma}_{\mathbf{y}} = (\sigma_{y_1}, \sigma_{y_2}, \ldots \sigma_{y_M})\)</span>, which are assumed to be Gaussian-distributed. What should we infer about the posterior probability distribution of the physical properties, i.e., given a set of prior probabilities <span class="math">\(p(\mathbf{x})\)</span>, plus our measurements, what is <span class="math">\(p(\mathbf{x} \mid \mathbf{y}_{\mathrm{obs}}, \mathbf{\sigma}_{\mathrm{y}})\)</span>?</p>
<p>The kernel density estimation algorithm that bayesphot uses to answer this question is described and derived in the slug methods paper. Bayesphot is implemented in two parts: a shared object library that is implemented in c, and that is compiled at the same time that slug is built, and a python wrapper class called <tt class="docutils literal"><span class="pre">bp</span></tt> that is included in the slugpy.bayesphot module. The following sections describe how to use <tt class="docutils literal"><span class="pre">bp</span></tt> objects to generate posterior PDFs.</p>
</div>
<div class="section" id="creating-bp-objects">
<h2>Creating <tt class="docutils literal"><span class="pre">bp</span></tt> Objects<a class="headerlink" href="#creating-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">bp</span></tt> class can be imported via:</p>
<div class="highlight-rest"><div class="highlight"><pre>from slugpy.bayesphot import *
</pre></div>
</div>
<p>or:</p>
<div class="highlight-rest"><div class="highlight"><pre>from slugpy.bayesphot import bp<span class="s">``</span>
</pre></div>
</div>
<p>Once imported, a <tt class="docutils literal"><span class="pre">bp</span></tt> object can be instantiated. The call signature for the <tt class="docutils literal"><span class="pre">bp</span></tt> constructor class is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def __init__(self, dataset, nphys, filters=None, bandwidth=&#39;auto&#39;,
             ktype=&#39;gaussian&#39;, priors=None, sample_density=None,
             reltol=1.0e-3, abstol=1.0e-10, leafsize=16):
</pre></div>
</div>
<p>A full description of all options is included in the <a class="reference internal" href="#ssec-slugpy-bayesphot"><em>Full Documentation of slugpy.bayesphot</em></a>, but the essential features are summarized here.</p>
<p>The argument <tt class="docutils literal"><span class="pre">dataset</span></tt> is an array of shape (N, M) that contains the library of N models that represents the training set for the Bayesian analysis. Each model consists of M properties; the first <tt class="docutils literal"><span class="pre">nphys</span></tt> of these are physical properties that are the quantities to be inferred from the observations, while the remaining ones are photometric properties. An important point is that the <tt class="docutils literal"><span class="pre">dataset</span></tt> object is NOT copied, so altering it after the <tt class="docutils literal"><span class="pre">bp</span></tt> object is created will result in erroneous results.</p>
<p>The <tt class="docutils literal"><span class="pre">priors</span></tt> and <tt class="docutils literal"><span class="pre">sample_density</span></tt> arguments are used to compute the weighting to apply to the input models. The <tt class="docutils literal"><span class="pre">priors</span></tt> argument specifies the prior probability to assign to each model; it can be either an array giving a prior probability directly, or a callable that can take the physical properties of models as an input and return the prior probability as an output. Similarly, the <tt class="docutils literal"><span class="pre">sample_density</span></tt> argument specifies the probablity distribution from which the physical models were selected; as with <tt class="docutils literal"><span class="pre">priors</span></tt>, it can be an array or a callable.</p>
<p>The <tt class="docutils literal"><span class="pre">bandwidth</span></tt> argument specifies the bandwidth to use in the kernel density estimation; this need not be the same in each dimension. The <tt class="docutils literal"><span class="pre">bandwidth</span></tt> can be specified as a float, in which case it is the same for every dimension, or as an array of M elements giving the bandwidth for every dimension. Finally, it can be set to the string <tt class="docutils literal"><span class="pre">auto</span></tt>, in which case the <tt class="docutils literal"><span class="pre">bp</span></tt> will attempt to make a reasonable choice of bandwidth autonomously. However, this autonomous choice will probably perform less well than something that is hand-chosen by the user based on their knowledge of the library. As a rule of thumb, bandwidths should be chosen so that, for typical input photometric values, there are ~10 simulations within the 1 kernel size.</p>
<p>Note that both <tt class="docutils literal"><span class="pre">priors</span></tt> and <tt class="docutils literal"><span class="pre">bandwidth</span></tt> are properties of the <tt class="docutils literal"><span class="pre">bp</span></tt> class, and can be altered after the <tt class="docutils literal"><span class="pre">bp</span></tt> object is created. This makes it possible to alter the priors and bandwidth without incurring the computational or memory cost of generating an entirely new <tt class="docutils literal"><span class="pre">bp</span></tt> object.</p>
</div>
<div class="section" id="using-bp-objects">
<h2>Using <tt class="docutils literal"><span class="pre">bp</span></tt> Objects<a class="headerlink" href="#using-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>Once a <tt class="docutils literal"><span class="pre">bp</span></tt> object is instantiated, it can be used to compute likelihood functions, marginal probabilities, and MCMC sample ensembles, and to search the library for the best matches to an input set of photometry.</p>
<p>The likelihood function is implemented via the <tt class="docutils literal"><span class="pre">bp.logL</span></tt> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre>def logL(self, physprop, photprop, photerr=None):
</pre></div>
</div>
<p>The argument <tt class="docutils literal"><span class="pre">physprop</span></tt> is a set of physical properties, the argument <tt class="docutils literal"><span class="pre">photprop</span></tt> is a set of photometric properties, and the argument <tt class="docutils literal"><span class="pre">photerr</span></tt> is an (optional) set of photometric errors. All of these must be arrays, the size of whose trailing dimension matches the number of physical properties (for <tt class="docutils literal"><span class="pre">physprop</span></tt>) or the number of photometric properties (for <tt class="docutils literal"><span class="pre">photprop</span></tt> and <tt class="docutils literal"><span class="pre">photerr</span></tt>); the leading dimensions of these arrays are broadcast together using normal broadcasting rules. The quantity returned is the log of the joint probability distribution of physical and photometric properties. Specifically, the quantity returned for each input set of physical and photometric properties is</p>
<div class="math">
\[\log p(\mathbf{x}, \mathbf{y}, \sigma_{\mathbf{y}}) = \log A \sum_{i=1}^N w_i G(\mathbf{x}, \mathbf{y}; \mathbf{h}')\]</div>
<p>where <span class="math">\(A\)</span> is a normalization constant chosen to ensure that the PDF integrated over all space is unity, <span class="math">\(\mathbf{x}\)</span> is the vector of physical properties, <span class="math">\(\mathbf{y}\)</span> is the vector of photometric properties, <span class="math">\(\sigma_\mathbf{y}\)</span> is the vector of photomtric errors, <span class="math">\(w_i\)</span> is the weight of the ith model as determined by the priors and sample density,</p>
<div class="math">
\[G\left(\mathbf{x}, \mathbf{y}; \mathbf{h}'\right) \propto \exp\left[-\left(\frac{x_1^2}{2h_{x_1}'^2} + \cdots + \frac{x_N^2}{2h_{x_N}'^2} + \frac{y_1^2}{2h_{y_1}'^2} + \cdots + \frac{y_M^2}{2h_{y_M}'^2} \right)\right]\]</div>
<p>is the N-dimensional Gaussian function, and</p>
<div class="math">
\[\mathbf{h'} = \sqrt{\mathbf{h}^2 + \sigma_{\mathbf{y}}^2}\]</div>
<p>is the modified bandwidth, which is equal to the bandwidth used for kernel density estimation added in quadrature sum with the errors in the photometric quantities (see the slug method paper for details).</p>
<p>Estimation of marginal PDFs is done via the <tt class="docutils literal"><span class="pre">bp.mpdf</span></tt> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre>def mpdf(self, idx, photprop, photerr=None, ngrid=128,
         qmin=None, qmax=None, grid=None, norm=True):
</pre></div>
</div>
<p>The argument <tt class="docutils literal"><span class="pre">idx</span></tt> is an int or a list of ints between 0 and nphys-1, which specifies for which physical quantity or physical quantities the marginal PDF is to be computed. These indices refer to the indices in the <tt class="docutils literal"><span class="pre">dataset</span></tt> array that was input when the <tt class="docutils literal"><span class="pre">bp</span></tt> object was instantiated. The arguments <tt class="docutils literal"><span class="pre">photprop</span></tt> and <tt class="docutils literal"><span class="pre">photerr</span></tt> give the photometric measurements and their errors for which the marginal PDFs are to be computed; they must be arrays whose trailing dimension is equal to the number of photometric quantities. The leading dimensions of these arrays are broadcast together following the normal broadcasting rules. By default each physical quantity will be estimated on a grid of 128 points, evenly spaced from the lowest value of that physical property in the model library to the highest value. The parameters <tt class="docutils literal"><span class="pre">qmin</span></tt>, <tt class="docutils literal"><span class="pre">qmax</span></tt>, <tt class="docutils literal"><span class="pre">ngrid</span></tt>, and <tt class="docutils literal"><span class="pre">grid</span></tt> can be used to override this behavior and set the grid of evaluation points manually. The function returns a tuple <tt class="docutils literal"><span class="pre">grid_out,</span> <span class="pre">pdf</span></tt>; here <tt class="docutils literal"><span class="pre">grid_out</span></tt> is the grid of points on which the marginal PDF has been computed, and <tt class="docutils literal"><span class="pre">pdf</span></tt> is the value of the marginal PDF evaluated at those gridpoints.</p>
<p>MCMC calculations are implemented via the method <tt class="docutils literal"><span class="pre">bp.mcmc</span></tt>; this method relies on the <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee</a> python module, and will only function if it is installed. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def mcmc(self, photprop, photerr=None, mc_walkers=100,
         mc_steps=500, mc_burn_in=50):
</pre></div>
</div>
<p>The quantities <tt class="docutils literal"><span class="pre">photprop</span></tt> and <tt class="docutils literal"><span class="pre">photerr</span></tt> have the same meaning as for <tt class="docutils literal"><span class="pre">bp.mpdf</span></tt>, and the quantities <tt class="docutils literal"><span class="pre">mc_walkers</span></tt>, <tt class="docutils literal"><span class="pre">mc_steps</span></tt>, and <tt class="docutils literal"><span class="pre">mc_burn_in</span></tt> are passed directly to <tt class="docutils literal"><span class="pre">emcee</span></tt>, and are described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee&#8217;s documentation</a>. The quantity returned is an array of sample points computed by the MCMC; its format is also described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee&#8217;s documentation</a>. Note that, although <tt class="docutils literal"><span class="pre">bp.mcmc</span></tt> can be used to compute marginal PDFs of the physical quantities, for marginal PDFs of 1 quantity or joint PDFs of 2 quantities it is almost always faster to use <tt class="docutils literal"><span class="pre">bp.mpdf</span></tt> than <tt class="docutils literal"><span class="pre">bp.mcmc</span></tt>. This is because <tt class="docutils literal"><span class="pre">bp.mpdf</span></tt> takes advantage of the fact that integrals of cuts through N-dimensional Gaussians can be integrated analytically to compute the marginal PDFs directly, though needing to evaluate the likelihood function point by point. In contrast, the general MCMC algorithm used by <tt class="docutils literal"><span class="pre">emcee</span></tt> effectively does the integral numerically.</p>
<p>The <tt class="docutils literal"><span class="pre">bp.bestmatch</span></tt> method searches through the model library and finds the N library entries that are closest to an input set of photometry. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def bestmatch(self, phot, nmatch=1, bandwidth_units=False):
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">phot</span></tt> is the set of photometric properties, which is identical to the <tt class="docutils literal"><span class="pre">photprop</span></tt> parameter used by <tt class="docutils literal"><span class="pre">logL</span></tt>, <tt class="docutils literal"><span class="pre">mpdf</span></tt>, and <tt class="docutils literal"><span class="pre">mcmc</span></tt>. The argument <tt class="docutils literal"><span class="pre">nmatch</span></tt> specifies how many matches to return, and the argument <tt class="docutils literal"><span class="pre">bandwidth_units</span></tt> specifies whether distances are to be measured using an ordinary Euclidean metric, or in units of the kernel bandwidth in a given direction. The function returns, for each input set of photometry, the physical and photometric properties of the <tt class="docutils literal"><span class="pre">nmatch</span></tt> models in the library that are closest to the input photometric values. This can be used to judge if a good match to the input photometry is present in the library.</p>
</div>
<div class="section" id="module-slugpy.bayesphot.bp">
<span id="full-documentation-of-slugpy-bayesphot"></span><span id="ssec-slugpy-bayesphot"></span><h2>Full Documentation of slugpy.bayesphot<a class="headerlink" href="#module-slugpy.bayesphot.bp" title="Permalink to this headline">¶</a></h2>
<p>This defines a class that can be used to estimate the PDF of physical
quantities from a set of input photometry in various bands, together
with a training data set.</p>
<dl class="class">
<dt id="slugpy.bayesphot.bp.bp">
<em class="property">class </em><tt class="descclassname">slugpy.bayesphot.bp.</tt><tt class="descname">bp</tt><big>(</big><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-06</em>, <em>leafsize=16</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that can be used to estimate the PDF of the physical
properties of stellar population from a training set plus a set of
measured photometric values.</p>
<dl class="docutils">
<dt>Properties</dt>
<dd><dl class="first last docutils">
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
all data points have equal prior probability</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;auto&#8217; | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
&#8216;auto&#8217;, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.__init__">
<tt class="descname">__init__</tt><big>(</big><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-06</em>, <em>leafsize=16</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bp object.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>dataset <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N, M)</span></dt>
<dd>training data set; this is a set of N sample stellar
populations, having M properties each; the first npys
represent physical properties (e.g., log mass, log age),
while the next M - nphys represent photometric
properties</dd>
<dt>npys <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of physical properties in dataset</dd>
<dt>filters <span class="classifier-delimiter">:</span> <span class="classifier">listlike of strings</span></dt>
<dd>names of photometric filters; not used, but can be
stored for convenience</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;auto&#8217; | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
&#8216;auto&#8217;, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
<dt>ktype <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>type of kernel to be used in densty estimation; allowed
values are &#8216;gaussian&#8217; (default), &#8216;epanechnikov&#8217;, and
&#8216;tophat&#8217;; only Gaussian can be used with error bars</dd>
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
all data points have equal prior probability</dd>
<dt>sample_density <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | &#8216;auto&#8217; | None</span></dt>
<dd>the density of the data samples at each data point; this
need not match the prior density; interpretation depends
on the type passed; array, shape (N): values are
interpreted as the density of data sampling at each
sample point; callable: the callable must take as an
argument an array of shape (N, nphys), and return an
array of shape (N) giving the sampling density at each
point; &#8216;auto&#8217;: the sample density will be computed
directly from the data set; note that this can be quite
slow for large data sets, so it is preferable to specify
this analytically if it is known; None: data are assumed
to be uniformly sampled</dd>
<dt>reltol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>relative error tolerance; errors on all returned
probabilities p will satisfy either
abs(p_est - p_true) &lt;= reltol * p_est   OR
abs(p_est - p_true) &lt;= abstol,
where p_est is the returned estimate and p_true is the
true value</dd>
<dt>abstol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>absolute error tolerance; see above</dd>
<dt>leafsize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data points in each leaf of the KD tree</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
<dt>Raises</dt>
<dd>IOError, if the bayesphot c library cannot be found</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.__weakref__">
<tt class="descname">__weakref__</tt><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.bandwidth">
<tt class="descname">bandwidth</tt><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The current bandwidth</p>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.bestmatch">
<tt class="descname">bestmatch</tt><big>(</big><em>phot</em>, <em>nmatch=1</em>, <em>bandwidth_units=False</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bestmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches through the simulation library and returns the closest
matches to an input set of photometry.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>nmatch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of matches to return; returned matches will be
ordered by distance from the input</dd>
<dt>bandwidth_units <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if False, distances are computed based on the
logarithmic difference in luminosity; if True, they are
measured in units of the bandwidth</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>matches <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (..., nmatch, nphys + nfilter)</span></dt>
<dd>best matches to the input photometry; shape in the
leading dimensions will be the same as for phot, and if
nmatch == 1 then that dimension will be omitted</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (..., nmatch)</span></dt>
<dd>distances between the matches and the input photometry</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.logL">
<tt class="descname">logL</tt><big>(</big><em>physprop</em>, <em>photprop</em>, <em>photerr=None</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the natural log of the likelihood
function evaluated at a particular log mass, log age,
extinction, and set of log luminosities</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>physprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (..., nphys)</span></dt>
<dd>array giving values of the physical properties; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>logL <span class="classifier-delimiter">:</span> <span class="classifier">float or arraylike</span></dt>
<dd>natural log of the likelihood function</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mcmc">
<tt class="descname">mcmc</tt><big>(</big><em>photprop</em>, <em>photerr=None</em>, <em>mc_walkers=100</em>, <em>mc_steps=500</em>, <em>mc_burn_in=50</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a sample of MCMC walkers sampling the
physical parameters at a specified set of photometric values.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>mc_walkers <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of walkers to use in the MCMC</dd>
<dt>mc_steps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps in the MCMC</dd>
<dt>mc_burn_in <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps to consider &#8220;burn-in&#8221; and discard</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of sample points returned by the MCMC</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf">
<tt class="descname">mpdf</tt><big>(</big><em>idx</em>, <em>photprop</em>, <em>photerr=None</em>, <em>ngrid=128</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><big>)</big><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal probability for one or mode physical
quantities for one or more input sets of photometric
properties. Output quantities are computed on a grid of
values, in the same style as meshgrid</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>index of the physical quantity whose PDF is to be
computed; if this is an iterable, the joint distribution of
the indicated quantities is returned</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, defaults to the minimum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, defaults to the maximum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf&#8217;s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input cluster; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.priors">
<tt class="descname">priors</tt><a class="headerlink" href="#slugpy.bayesphot.bp.bp.priors" title="Permalink to this definition">¶</a></dt>
<dd><p>The current set of prior probabilities for every
simulation in the library</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">bayesphot: Bayesian Inference for Stochastic Stellar Populations</a><ul>
<li><a class="reference internal" href="#what-does-bayesphot-do">What Does bayesphot Do?</a></li>
<li><a class="reference internal" href="#creating-bp-objects">Creating <tt class="docutils literal"><span class="pre">bp</span></tt> Objects</a></li>
<li><a class="reference internal" href="#using-bp-objects">Using <tt class="docutils literal"><span class="pre">bp</span></tt> Objects</a></li>
<li><a class="reference internal" href="#module-slugpy.bayesphot.bp">Full Documentation of slugpy.bayesphot</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cloudy.html"
                        title="previous chapter">cloudy_slug: An Automated Interface to cloudy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cluster_slug.html"
                        title="next chapter">cluster_slug: Bayesian Inference of Star Cluster Properties</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/bayesphot.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cluster_slug.html" title="cluster_slug: Bayesian Inference of Star Cluster Properties"
             >next</a> |</li>
        <li class="right" >
          <a href="cloudy.html" title="cloudy_slug: An Automated Interface to cloudy"
             >previous</a> |</li>
        <li><a href="index.html">slug 2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Mark Krumholz, Michele Fumagalli, et al..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>