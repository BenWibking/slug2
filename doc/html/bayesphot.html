<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>bayesphot: Bayesian Inference for Stochastic Stellar Populations &mdash; slug 2.0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="slug 2.0 documentation" href="index.html" />
    <link rel="next" title="cluster_slug: Bayesian Inference of Star Cluster Properties" href="cluster_slug.html" />
    <link rel="prev" title="cloudy_slug: An Automated Interface to cloudy" href="cloudy.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cluster_slug.html" title="cluster_slug: Bayesian Inference of Star Cluster Properties"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cloudy.html" title="cloudy_slug: An Automated Interface to cloudy"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">slug 2.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="bayesphot-bayesian-inference-for-stochastic-stellar-populations">
<span id="sec-bayesphot"></span><h1>bayesphot: Bayesian Inference for Stochastic Stellar Populations<a class="headerlink" href="#bayesphot-bayesian-inference-for-stochastic-stellar-populations" title="Permalink to this headline">¶</a></h1>
<div class="section" id="what-does-bayesphot-do">
<h2>What Does bayesphot Do?<a class="headerlink" href="#what-does-bayesphot-do" title="Permalink to this headline">¶</a></h2>
<p>Bayesphot is a package for performing Bayesian inference for the physical properties of a stellar system using its measured photometric properties, in a case where the photometric properties vary non-deterministically with the physical properties. Formally, bayesphot answers the following question: consider a stellar system characterized by a vector of <span class="math">\(\mathbf{x} = (x_1, x_2, \ldots x_N)\)</span> physical properties. We have a physical model that lets us sample the expected photometric properties as a function of physical properties, i.e., that for some sample of <span class="math">\(K\)</span> systems with physical properties <span class="math">\(\mathbf{x}_k\)</span> we are able to compute the corresponding photometric properties <span class="math">\(\mathbf{y}_k = \mathbf{y} = (y_1, y_2, \ldots y_M)_k\)</span>. Now suppose that we observe such a system, and we observe it to have photometric properties <span class="math">\(\mathbf{y}_{\mathrm{obs}}\)</span>, with some set of photometric errors <span class="math">\(\mathbf{\sigma}_{\mathbf{y}} = (\sigma_{y_1}, \sigma_{y_2}, \ldots \sigma_{y_M})\)</span>, which are assumed to be Gaussian-distributed. What should we infer about the posterior probability distribution of the physical properties, i.e., given a set of prior probabilities <span class="math">\(p(\mathbf{x})\)</span>, plus our measurements, what is <span class="math">\(p(\mathbf{x} \mid \mathbf{y}_{\mathrm{obs}}, \mathbf{\sigma}_{\mathrm{y}})\)</span>?</p>
<p>The kernel density estimation algorithm that bayesphot uses to answer this question is described and derived in the slug methods paper. Bayesphot is implemented in two parts: a shared object library that is implemented in c, and that is compiled at the same time that slug is built, and a python wrapper class called <code class="docutils literal"><span class="pre">bp</span></code> that is included in the slugpy.bayesphot module. The following sections describe how to use <code class="docutils literal"><span class="pre">bp</span></code> objects to generate posterior PDFs.</p>
</div>
<div class="section" id="creating-bp-objects">
<h2>Creating <code class="docutils literal"><span class="pre">bp</span></code> Objects<a class="headerlink" href="#creating-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">bp</span></code> class can be imported via:</p>
<div class="highlight-rest"><div class="highlight"><pre>from slugpy.bayesphot import *
</pre></div>
</div>
<p>or:</p>
<div class="highlight-rest"><div class="highlight"><pre>from slugpy.bayesphot import bp<span class="s">``</span>
</pre></div>
</div>
<p>Once imported, a <code class="docutils literal"><span class="pre">bp</span></code> object can be instantiated. The call signature for the <code class="docutils literal"><span class="pre">bp</span></code> constructor class is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def __init__(self, dataset, nphys, filters=None, bandwidth=&#39;auto&#39;,
             ktype=&#39;gaussian&#39;, priors=None, sample_density=None,
             reltol=1.0e-3, abstol=1.0e-10, leafsize=16):
</pre></div>
</div>
<p>A full description of all options is included in the <a class="reference internal" href="#ssec-slugpy-bayesphot"><span>Full Documentation of slugpy.bayesphot</span></a>, but the essential features are summarized here.</p>
<p>The argument <code class="docutils literal"><span class="pre">dataset</span></code> is an array of shape (N, M) that contains the library of N models that represents the training set for the Bayesian analysis. Each model consists of M properties; the first <code class="docutils literal"><span class="pre">nphys</span></code> of these are physical properties that are the quantities to be inferred from the observations, while the remaining ones are photometric properties. An important point is that the <code class="docutils literal"><span class="pre">dataset</span></code> object is NOT copied, so altering it after the <code class="docutils literal"><span class="pre">bp</span></code> object is created will result in erroneous results.</p>
<p>The <code class="docutils literal"><span class="pre">priors</span></code> and <code class="docutils literal"><span class="pre">sample_density</span></code> arguments are used to compute the weighting to apply to the input models. The <code class="docutils literal"><span class="pre">priors</span></code> argument specifies the prior probability to assign to each model; it can be either an array giving a prior probability directly, or a callable that can take the physical properties of models as an input and return the prior probability as an output. Similarly, the <code class="docutils literal"><span class="pre">sample_density</span></code> argument specifies the probablity distribution from which the physical models were selected; as with <code class="docutils literal"><span class="pre">priors</span></code>, it can be an array or a callable.</p>
<p>The <code class="docutils literal"><span class="pre">bandwidth</span></code> argument specifies the bandwidth to use in the kernel density estimation; this need not be the same in each dimension. The <code class="docutils literal"><span class="pre">bandwidth</span></code> can be specified as a float, in which case it is the same for every dimension, or as an array of M elements giving the bandwidth for every dimension. Finally, it can be set to the string <code class="docutils literal"><span class="pre">auto</span></code>, in which case the <code class="docutils literal"><span class="pre">bp</span></code> will attempt to make a reasonable choice of bandwidth autonomously. However, this autonomous choice will probably perform less well than something that is hand-chosen by the user based on their knowledge of the library. As a rule of thumb, bandwidths should be chosen so that, for typical input photometric values, there are ~10 simulations within the 1 kernel size.</p>
<p>Note that both <code class="docutils literal"><span class="pre">priors</span></code> and <code class="docutils literal"><span class="pre">bandwidth</span></code> are properties of the <code class="docutils literal"><span class="pre">bp</span></code> class, and can be altered after the <code class="docutils literal"><span class="pre">bp</span></code> object is created. This makes it possible to alter the priors and bandwidth without incurring the computational or memory cost of generating an entirely new <code class="docutils literal"><span class="pre">bp</span></code> object.</p>
</div>
<div class="section" id="using-bp-objects">
<h2>Using <code class="docutils literal"><span class="pre">bp</span></code> Objects<a class="headerlink" href="#using-bp-objects" title="Permalink to this headline">¶</a></h2>
<p>Once a <code class="docutils literal"><span class="pre">bp</span></code> object is instantiated, it can be used to compute likelihood functions, marginal probabilities, and MCMC sample ensembles, and to search the library for the best matches to an input set of photometry.</p>
<p>The likelihood function is implemented via the <code class="docutils literal"><span class="pre">bp.logL</span></code> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre>def logL(self, physprop, photprop, photerr=None):
</pre></div>
</div>
<p>The argument <code class="docutils literal"><span class="pre">physprop</span></code> is a set of physical properties, the argument <code class="docutils literal"><span class="pre">photprop</span></code> is a set of photometric properties, and the argument <code class="docutils literal"><span class="pre">photerr</span></code> is an (optional) set of photometric errors. All of these must be arrays, the size of whose trailing dimension matches the number of physical properties (for <code class="docutils literal"><span class="pre">physprop</span></code>) or the number of photometric properties (for <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code>); the leading dimensions of these arrays are broadcast together using normal broadcasting rules. The quantity returned is the log of the joint probability distribution of physical and photometric properties. Specifically, the quantity returned for each input set of physical and photometric properties is</p>
<div class="math">
\[\log p(\mathbf{x}, \mathbf{y}, \sigma_{\mathbf{y}}) = \log A \sum_{i=1}^N w_i G(\mathbf{x}, \mathbf{y}; \mathbf{h}')\]</div>
<p>where <span class="math">\(A\)</span> is a normalization constant chosen to ensure that the PDF integrated over all space is unity, <span class="math">\(\mathbf{x}\)</span> is the vector of physical properties, <span class="math">\(\mathbf{y}\)</span> is the vector of photometric properties, <span class="math">\(\sigma_\mathbf{y}\)</span> is the vector of photomtric errors, <span class="math">\(w_i\)</span> is the weight of the ith model as determined by the priors and sample density,</p>
<div class="math">
\[G\left(\mathbf{x}, \mathbf{y}; \mathbf{h}'\right) \propto \exp\left[-\left(\frac{x_1^2}{2h_{x_1}'^2} + \cdots + \frac{x_N^2}{2h_{x_N}'^2} + \frac{y_1^2}{2h_{y_1}'^2} + \cdots + \frac{y_M^2}{2h_{y_M}'^2} \right)\right]\]</div>
<p>is the N-dimensional Gaussian function, and</p>
<div class="math">
\[\mathbf{h'} = \sqrt{\mathbf{h}^2 + \sigma_{\mathbf{y}}^2}\]</div>
<p>is the modified bandwidth, which is equal to the bandwidth used for kernel density estimation added in quadrature sum with the errors in the photometric quantities (see the slug method paper for details).</p>
<p>Estimation of marginal PDFs is done via the <code class="docutils literal"><span class="pre">bp.mpdf</span></code> method, which has the call signature:</p>
<div class="highlight-rest"><div class="highlight"><pre>def mpdf(self, idx, photprop, photerr=None, ngrid=128,
         qmin=None, qmax=None, grid=None, norm=True):
</pre></div>
</div>
<p>The argument <code class="docutils literal"><span class="pre">idx</span></code> is an int or a list of ints between 0 and nphys-1, which specifies for which physical quantity or physical quantities the marginal PDF is to be computed. These indices refer to the indices in the <code class="docutils literal"><span class="pre">dataset</span></code> array that was input when the <code class="docutils literal"><span class="pre">bp</span></code> object was instantiated. The arguments <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code> give the photometric measurements and their errors for which the marginal PDFs are to be computed; they must be arrays whose trailing dimension is equal to the number of photometric quantities. The leading dimensions of these arrays are broadcast together following the normal broadcasting rules. By default each physical quantity will be estimated on a grid of 128 points, evenly spaced from the lowest value of that physical property in the model library to the highest value. The parameters <code class="docutils literal"><span class="pre">qmin</span></code>, <code class="docutils literal"><span class="pre">qmax</span></code>, <code class="docutils literal"><span class="pre">ngrid</span></code>, and <code class="docutils literal"><span class="pre">grid</span></code> can be used to override this behavior and set the grid of evaluation points manually. The function returns a tuple <code class="docutils literal"><span class="pre">grid_out,</span> <span class="pre">pdf</span></code>; here <code class="docutils literal"><span class="pre">grid_out</span></code> is the grid of points on which the marginal PDF has been computed, and <code class="docutils literal"><span class="pre">pdf</span></code> is the value of the marginal PDF evaluated at those gridpoints.</p>
<p>MCMC calculations are implemented via the method <code class="docutils literal"><span class="pre">bp.mcmc</span></code>; this method relies on the <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee</a> python module, and will only function if it is installed. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def mcmc(self, photprop, photerr=None, mc_walkers=100,
         mc_steps=500, mc_burn_in=50):
</pre></div>
</div>
<p>The quantities <code class="docutils literal"><span class="pre">photprop</span></code> and <code class="docutils literal"><span class="pre">photerr</span></code> have the same meaning as for <code class="docutils literal"><span class="pre">bp.mpdf</span></code>, and the quantities <code class="docutils literal"><span class="pre">mc_walkers</span></code>, <code class="docutils literal"><span class="pre">mc_steps</span></code>, and <code class="docutils literal"><span class="pre">mc_burn_in</span></code> are passed directly to <code class="docutils literal"><span class="pre">emcee</span></code>, and are described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee&#8217;s documentation</a>. The quantity returned is an array of sample points computed by the MCMC; its format is also described in <a class="reference external" href="http://dan.iel.fm/emcee/current/">emcee&#8217;s documentation</a>. Note that, although <code class="docutils literal"><span class="pre">bp.mcmc</span></code> can be used to compute marginal PDFs of the physical quantities, for marginal PDFs of 1 quantity or joint PDFs of 2 quantities it is almost always faster to use <code class="docutils literal"><span class="pre">bp.mpdf</span></code> than <code class="docutils literal"><span class="pre">bp.mcmc</span></code>. This is because <code class="docutils literal"><span class="pre">bp.mpdf</span></code> takes advantage of the fact that integrals of cuts through N-dimensional Gaussians can be integrated analytically to compute the marginal PDFs directly, though needing to evaluate the likelihood function point by point. In contrast, the general MCMC algorithm used by <code class="docutils literal"><span class="pre">emcee</span></code> effectively does the integral numerically.</p>
<p>The <code class="docutils literal"><span class="pre">bp.bestmatch</span></code> method searches through the model library and finds the N library entries that are closest to an input set of photometry. The call signature is:</p>
<div class="highlight-rest"><div class="highlight"><pre>def bestmatch(self, phot, nmatch=1, bandwidth_units=False):
</pre></div>
</div>
<p>Here <code class="docutils literal"><span class="pre">phot</span></code> is the set of photometric properties, which is identical to the <code class="docutils literal"><span class="pre">photprop</span></code> parameter used by <code class="docutils literal"><span class="pre">logL</span></code>, <code class="docutils literal"><span class="pre">mpdf</span></code>, and <code class="docutils literal"><span class="pre">mcmc</span></code>. The argument <code class="docutils literal"><span class="pre">nmatch</span></code> specifies how many matches to return, and the argument <code class="docutils literal"><span class="pre">bandwidth_units</span></code> specifies whether distances are to be measured using an ordinary Euclidean metric, or in units of the kernel bandwidth in a given direction. The function returns, for each input set of photometry, the physical and photometric properties of the <code class="docutils literal"><span class="pre">nmatch</span></code> models in the library that are closest to the input photometric values. This can be used to judge if a good match to the input photometry is present in the library.</p>
</div>
<div class="section" id="module-slugpy.bayesphot.bp">
<span id="full-documentation-of-slugpy-bayesphot"></span><span id="ssec-slugpy-bayesphot"></span><h2>Full Documentation of slugpy.bayesphot<a class="headerlink" href="#module-slugpy.bayesphot.bp" title="Permalink to this headline">¶</a></h2>
<p>This defines a class that can be used to estimate the PDF of physical
quantities from a set of input photometry in various bands, together
with a training data set.</p>
<dl class="class">
<dt id="slugpy.bayesphot.bp.bp">
<em class="property">class </em><code class="descclassname">slugpy.bayesphot.bp.</code><code class="descname">bp</code><span class="sig-paren">(</span><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-06</em>, <em>leafsize=16</em>, <em>nosort=None</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp" title="Permalink to this definition">¶</a></dt>
<dd><p>A class that can be used to estimate the PDF of the physical
properties of stellar population from a training set plus a set of
measured photometric values.</p>
<dl class="docutils">
<dt>Properties</dt>
<dd><dl class="first last docutils">
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
all data points have equal prior probability</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;auto&#8217; | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
&#8216;auto&#8217;, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>dataset</em>, <em>nphys</em>, <em>filters=None</em>, <em>bandwidth='auto'</em>, <em>ktype='gaussian'</em>, <em>priors=None</em>, <em>sample_density=None</em>, <em>reltol=0.01</em>, <em>abstol=1e-06</em>, <em>leafsize=16</em>, <em>nosort=None</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a bp object.</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>dataset <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N, M)</span></dt>
<dd>training data set; this is a set of N sample stellar
populations, having M properties each; the first nphys
represent physical properties (e.g., log mass, log age),
while the next M - nphys represent photometric
properties</dd>
<dt>nphys <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of physical properties in dataset</dd>
<dt>filters <span class="classifier-delimiter">:</span> <span class="classifier">listlike of strings</span></dt>
<dd>names of photometric filters; not used, but can be
stored for convenience</dd>
<dt>bandwidth <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;auto&#8217; | float | array, shape (M)</span></dt>
<dd>bandwidth for kernel density estimation; if set to
&#8216;auto&#8217;, the bandwidth will be estimated automatically; if
set to a scalar quantity, the same bandwidth is used for all
dimensions</dd>
<dt>ktype <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>type of kernel to be used in densty estimation; allowed
values are &#8216;gaussian&#8217; (default), &#8216;epanechnikov&#8217;, and
&#8216;tophat&#8217;; only Gaussian can be used with error bars</dd>
<dt>priors <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | None</span></dt>
<dd>prior probability on each data point; interpretation
depends on the type passed; array, shape (N): values are
interpreted as the prior probability of each data point;
callable: the callable must take as an argument an array
of shape (N, nphys), and return an array of shape (N)
giving the prior probability at each data point; None:
all data points have equal prior probability</dd>
<dt>sample_density <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (N) | callable | &#8216;auto&#8217; | None</span></dt>
<dd>the density of the data samples at each data point; this
need not match the prior density; interpretation depends
on the type passed; array, shape (N): values are
interpreted as the density of data sampling at each
sample point; callable: the callable must take as an
argument an array of shape (N, nphys), and return an
array of shape (N) giving the sampling density at each
point; &#8216;auto&#8217;: the sample density will be computed
directly from the data set; note that this can be quite
slow for large data sets, so it is preferable to specify
this analytically if it is known; None: data are assumed
to be uniformly sampled</dd>
<dt>reltol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>relative error tolerance; errors on all returned
probabilities p will satisfy either
abs(p_est - p_true) &lt;= reltol * p_est   OR
abs(p_est - p_true) &lt;= abstol,
where p_est is the returned estimate and p_true is the
true value</dd>
<dt>abstol <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd>absolute error tolerance; see above</dd>
<dt>leafsize <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of data points in each leaf of the KD tree</dd>
<dt>nosort <span class="classifier-delimiter">:</span> <span class="classifier">arraylike of bool, shape (N) | None</span></dt>
<dd>if specified, this keyword causes the KD tree not to be
sorted along the dimensions for which nosort is True</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd>Nothing</dd>
<dt>Raises</dt>
<dd>IOError, if the bayesphot c library cannot be found</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.__weakref__">
<code class="descname">__weakref__</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.__weakref__" title="Permalink to this definition">¶</a></dt>
<dd><p>list of weak references to the object (if defined)</p>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.bandwidth">
<code class="descname">bandwidth</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>The current bandwidth</p>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.bestmatch">
<code class="descname">bestmatch</code><span class="sig-paren">(</span><em>phot</em>, <em>photerr=None</em>, <em>nmatch=1</em>, <em>bandwidth_units=False</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.bestmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Searches through the simulation library and returns the closest
matches to an input set of photometry.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors, which must have the
same shape as phot; if this is not None,
then distances will be measured in units of the
photometric error if bandwidth_units is False, or in
units of the bandwidth added in quadrature with the
errors if it is True</dd>
<dt>nmatch <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of matches to return; returned matches will be
ordered by distance from the input</dd>
<dt>bandwidth_units <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if False, distances are computed based on the
logarithmic difference in luminosity; if True, they are
measured in units of the bandwidth</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>matches <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (..., nmatch, nphys + nfilter)</span></dt>
<dd>best matches to the input photometry; shape in the
leading dimensions will be the same as for phot, and if
nmatch == 1 then that dimension will be omitted</dd>
<dt>dist <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (..., nmatch)</span></dt>
<dd>distances between the matches and the input photometry</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.logL">
<code class="descname">logL</code><span class="sig-paren">(</span><em>physprop</em>, <em>photprop</em>, <em>photerr=None</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.logL" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns the natural log of the likelihood
function evaluated at a particular log mass, log age,
extinction, and set of log luminosities</p>
<dl class="docutils">
<dt>Parameters</dt>
<dd><dl class="first last docutils">
<dt>physprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (..., nphys)</span></dt>
<dd>array giving values of the physical properties; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>logL <span class="classifier-delimiter">:</span> <span class="classifier">float or arraylike</span></dt>
<dd>natural log of the likelihood function</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.make_approx_phot">
<code class="descname">make_approx_phot</code><span class="sig-paren">(</span><em>phys</em>, <em>squeeze=True</em>, <em>filter_ignore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.make_approx_phot" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object that can be used for a fast approximation of
the PDF of photometric properties that corresponds to a set of
physical properties. The PDF produced by summing over the
points returned is guaranteed to account for at least 1-reltol
of the marginal photometric probability, and to represent the
shape of the PDF in photometric space within a local accuracy
of reltol as well.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phys <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nphys) or (N, nphys)</span></dt>
<dd>the set or sets of physical properties for which the
approximation is to be generated</dd>
<dt>squeeze <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, the representation returned will be squeezed to
minimize the number of points included, using reltol as
the error tolerance</dd>
<dt>filter_ignore <span class="classifier-delimiter">:</span> <span class="classifier">None or listlike of bool</span></dt>
<dd>if None, the kernel density representation returned
covers all filters; otherwise this must be a listlike of
bool, one entry per filter, with a value of False
indicating that filter should be excluded from the
values returned; suppressing filters can allow for more
efficient representations</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, nphot), or a list of such arrays</span></dt>
<dd>an array containing the list of points to be used for
the approximation, where nphot is the number of
photometric filters being returned</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M), or a list of such arrays</span></dt>
<dd>an array containing the weights of the points</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.make_approx_phys">
<code class="descname">make_approx_phys</code><span class="sig-paren">(</span><em>phot</em>, <em>photerr=None</em>, <em>squeeze=True</em>, <em>phys_ignore=None</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.make_approx_phys" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an object that can be used for a fast approximation of
the PDF of physical properties that corresponds to a set of
photometric properties. The PDF produced by summing over the
points returned is guaranteed to account for at least 1-reltol
of the marginal photometric probability, and to represent the
shape of the PDF in photometric space within a local accuracy
of reltol as well.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>phot <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (N, nfilter)</span></dt>
<dd>the set or sets of photometric properties for which the
approximation is to be generated</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (N, nfilter)</span></dt>
<dd>array giving photometric errors; the number of elements
in the output lists will be the size that results from
broadcasting together the leading dimensions of phot and
photerr</dd>
<dt>squeeze <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, the representation returned will be squeezed to
minimize the number of points included, using reltol as
the error tolerance</dd>
<dt>phys_ignore <span class="classifier-delimiter">:</span> <span class="classifier">None or listlike of bool</span></dt>
<dd>if None, the kernel density representation returned
covers all physical properties; otherwise this must be a
listlike of bool, one entry per physical dimension, with
a value of False indicating that dimension should be
excluded from the values returned; suppressing
dimensions can allow for more efficient representations</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, nphys), or a list of such arrays</span></dt>
<dd>an array containing the list of points to be used for
the approximation, where nphys is the number of
physical dimensions being returned</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M), or a list of such arrays</span></dt>
<dd>an array containing the weights of the points</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mcmc">
<code class="descname">mcmc</code><span class="sig-paren">(</span><em>photprop</em>, <em>photerr=None</em>, <em>mc_walkers=100</em>, <em>mc_steps=500</em>, <em>mc_burn_in=50</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mcmc" title="Permalink to this definition">¶</a></dt>
<dd><p>This function returns a sample of MCMC walkers sampling the
physical parameters at a specified set of photometric values.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>mc_walkers <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of walkers to use in the MCMC</dd>
<dt>mc_steps <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps in the MCMC</dd>
<dt>mc_burn_in <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd>number of steps to consider &#8220;burn-in&#8221; and discard</dd>
</dl>
</dd>
<dt>Returns</dt>
<dd><dl class="first last docutils">
<dt>samples <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of sample points returned by the MCMC</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf">
<code class="descname">mpdf</code><span class="sig-paren">(</span><em>idx</em>, <em>photprop</em>, <em>photerr=None</em>, <em>ngrid=128</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal probability for one or mode physical
quantities for one or more input sets of photometric
properties. Output quantities are computed on a grid of
values, in the same style as meshgrid.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>idx <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>index of the physical quantity whose PDF is to be
computed; if this is an iterable, the joint distribution of
the indicated quantities is returned</dd>
<dt>photprop <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving the photometric values; for a
multidimensional array, the operation is vectorized over
the leading dimensions</dd>
<dt>photerr <span class="classifier-delimiter">:</span> <span class="classifier">arraylike, shape (nfilter) or (..., nfilter)</span></dt>
<dd>array giving photometric errors; for a multidimensional
array, the operation is vectorized over the leading
dimensions</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, defaults to the minimum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, defaults to the maximum value in the
library; if this is an iterable, it must contain the
same number of elements as idx</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf&#8217;s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input cluster; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="slugpy.bayesphot.bp.bp.mpdf_approx">
<code class="descname">mpdf_approx</code><span class="sig-paren">(</span><em>x</em>, <em>wgts</em>, <em>dims='phys'</em>, <em>dims_return=None</em>, <em>ngrid=64</em>, <em>qmin=None</em>, <em>qmax=None</em>, <em>grid=None</em>, <em>norm=True</em><span class="sig-paren">)</span><a class="headerlink" href="#slugpy.bayesphot.bp.bp.mpdf_approx" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the marginal posterior PDF computed from a kernel
density approximation returned by make_approx_phys or
make_approx_phot. Outputs are computed on a grid of values, in
the same style as meshgrid.</p>
<dl class="docutils">
<dt>Parameters:</dt>
<dd><dl class="first last docutils">
<dt>x <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M, ndim), or a list of such arrays</span></dt>
<dd>array of points retured by make_approx_phot or
make_approx_phys</dd>
<dt>wgts <span class="classifier-delimiter">:</span> <span class="classifier">array, shape (M) or a list of such arrays</span></dt>
<dd>array of weights returned by make_approx_phot or
make_approx_phys</dd>
<dt>dims <span class="classifier-delimiter">:</span> <span class="classifier">&#8216;phys&#8217; | &#8216;phot&#8217; | arraylike of ints</span></dt>
<dd>dimensions covered by x and wgts; the strings &#8216;phys&#8217; or
&#8216;phot&#8217; indicate that they cover all physical or
photometric dimensions, and correspond to the defaults
returned by make_approx_phys and make_approx_phot,
respectively; if dims is an array of ints, these specify
the dimensions covered by x and wgts, where the
physical dimensions are numbered 0, 1, ... nphys-1, and
the photometric ones are nphys, nphys+1,
... nphys+nphot-1</dd>
<dt>dims_return <span class="classifier-delimiter">:</span> <span class="classifier">None or arraylike of ints</span></dt>
<dd>if None, the output PDF has the same dimensions as
specified in dms; if not, then dimreturn must be a
subset of dim, and a marginal PDF in certain dimensions
will be generated</dd>
<dt>ngrid <span class="classifier-delimiter">:</span> <span class="classifier">int or listlike containing ints</span></dt>
<dd>number of points in each dimension of the output grid;
if this is an iterable, it must have the same number of
elements as idx</dd>
<dt>qmin <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>minimum value in the output grid in each quantity; if
left as None, the range is chosen automatically to zoom in
on the maximum of the final PDF; if this is an iterable,
it must contain the same number of elements as idx</dd>
<dt>qmax <span class="classifier-delimiter">:</span> <span class="classifier">float or listlike</span></dt>
<dd>maximum value in the output grid in each quantity; if
left as None, the range is chosen automatically to zoom in
on the maximum of the final PDF; if this is an iterable,
it must contain the same number of elements as idx</dd>
<dt>grid <span class="classifier-delimiter">:</span> <span class="classifier">listlike of arrays</span></dt>
<dd>set of values defining the grid on which the PDF is to
be evaluated, in the same format used by meshgrid</dd>
<dt>norm <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd>if True, returned pdf&#8217;s will be normalized to integrate
to 1</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>grid_out <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of values at which the PDF is evaluated; contents
are the same as returned by meshgrid</dd>
<dt>pdf <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd>array of marginal posterior probabilities at each point
of the output grid, for each input cluster; the leading
dimensions match the leading dimensions produced by
broadcasting the leading dimensions of photprop and
photerr together, while the trailing dimensions match
the dimensions of the output grid</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="slugpy.bayesphot.bp.bp.priors">
<code class="descname">priors</code><a class="headerlink" href="#slugpy.bayesphot.bp.bp.priors" title="Permalink to this definition">¶</a></dt>
<dd><p>The current set of prior probabilities for every
simulation in the library</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">bayesphot: Bayesian Inference for Stochastic Stellar Populations</a><ul>
<li><a class="reference internal" href="#what-does-bayesphot-do">What Does bayesphot Do?</a></li>
<li><a class="reference internal" href="#creating-bp-objects">Creating <code class="docutils literal"><span class="pre">bp</span></code> Objects</a></li>
<li><a class="reference internal" href="#using-bp-objects">Using <code class="docutils literal"><span class="pre">bp</span></code> Objects</a></li>
<li><a class="reference internal" href="#module-slugpy.bayesphot.bp">Full Documentation of slugpy.bayesphot</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="cloudy.html"
                        title="previous chapter">cloudy_slug: An Automated Interface to cloudy</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cluster_slug.html"
                        title="next chapter">cluster_slug: Bayesian Inference of Star Cluster Properties</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/bayesphot.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2014, Mark Krumholz, Michele Fumagalli, et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.2</a>
      
      |
      <a href="_sources/bayesphot.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>